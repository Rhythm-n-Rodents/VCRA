function nf = fun_analysis_get_node_branching_geometric_features_by_label(vessel_graph, node_label_list, link_label_list)
% fun_analysis_get_node_branching_geometric_features_by_label computes the
% link length of each node and the angle between links. The orientation of
% the link is defined by its end-to-end vector. 
% Input: 
%   vessel_graph: structure generated by fun_skeleton_to_graph
%   node_label_list: numerical vector, label of nodes to compute the feature
%   link_label_list: numerical vector, label of links that have the 
%   precomputed link features
% 
% Implemented by Xiang Ji on Jun 19, 2019
nf = fun_initialized_structure_array_with_fieldname_list({'link_length',...
    'link_ori_ep_cos', 'link_ep2ep_cos', 'link_length_max', 'link_length_min',...
    'link_length_mean', 'link_length_median', 'no_nan_Q', ...
    'link_ori_ep_det', 'link_ep2ep_det', 'link_radius', ...
    'link_ori_ep_sin_elevation', 'link_ep2ep_sin_elevation', ...
    'link_ori_ep_cos_elevation', 'link_ep2ep_cos_elevation'});
num_node = numel(node_label_list);
[nf.link_length_max, nf.link_length_min, nf.link_length_mean, nf.link_length_median, ...
    nf.link_ori_ep_det, nf.link_ep2ep_det, ...
    nf.link_ori_ep_sin_elevation, nf.link_ep2ep_sin_elevation, ...
    nf.link_ori_ep_cos_elevation, nf.link_ep2ep_cos_elevation] = deal(nan(num_node, 1));
[nf.link_length, nf.link_ori_ep_cos, nf.link_ep2ep_cos, nf.link_radius] = deal(cell(num_node, 1));
[nf.no_nan_Q] = deal(true(num_node, 1));
if num_node == 0
    return;    
end
% Find the link that are connected to the nodes:
connected_link_label_list = unique(cat(1, vessel_graph.node.connected_link_label{node_label_list}));
% Compute link geometric features
if isfield(vessel_graph.link, 'features') && (size(vessel_graph.link.features, 1) == numel(link_label_list))
    % Use precomptued link features
    link_compute_feature_label = setdiff(connected_link_label_list, link_label_list);
    extra_link_features = fun_analysis_get_link_features_by_label(vessel_graph, link_compute_feature_label, {'geometry', 'dt'});
    link_geometric_features = cat(1, vessel_graph.link.features(:, extra_link_features.Properties.VariableNames), ...
        extra_link_features);
    link_label_list_1 = cat(1, link_label_list, link_compute_feature_label);
else
    % Compute all the needed link feautres here
    link_label_list_1 = connected_link_label_list;
    link_geometric_features = fun_analysis_get_link_features_by_label(vessel_graph, link_label_list_1, {'geometry', 'dt'});    
end
% Map from link label to list ind
map_link_label_2_feature_list_ind = zeros(vessel_graph.link.num_cc, 1);
map_link_label_2_feature_list_ind(link_label_list_1) = 1 : numel(link_label_list_1);
%% Connected link 
% Add the following features: 
% 1. Length of links that connected to the node, sorted from short to long.
% 2. Angle between links 
% 3. Check if these link are on a plane
for iter_node = 1 : num_node
    tmp_node_label = node_label_list(iter_node);
%     tmp_node_degree = vessel_graph.node.num_link(tmp_node_label);
    tmp_neighbor_link_label = vessel_graph.node.connected_link_label{tmp_node_label};
    if isempty(tmp_neighbor_link_label)
       fprintf('Node %d has no link connects to it. The number of voxels in the node is %d\n', ...
           tmp_node_label, vessel_graph.node.num_voxel_per_cc(tmp_node_label));
       nf.no_nan_Q(iter_node) = false;
       continue;
    end    
    tmp_num_neighbor_links = numel(tmp_neighbor_link_label);
    % Length of links connected to the node
    tmp_neighbor_link_list_ind = map_link_label_2_feature_list_ind(tmp_neighbor_link_label);
    assert(all(tmp_neighbor_link_list_ind > 0), 'Exist neighboring link whose features is not available');
    tmp_neighbor_link_length = link_geometric_features.length(tmp_neighbor_link_list_ind);
    [tmp_neighbor_link_length, tmp_idx] = sort(tmp_neighbor_link_length, 'descend');
    tmp_neighbor_link_label = tmp_neighbor_link_label(tmp_idx);
    tmp_neighbor_link_list_ind = tmp_neighbor_link_list_ind(tmp_idx);
    
    nf.link_length{iter_node} = tmp_neighbor_link_length;
    nf.link_length_max(iter_node) = tmp_neighbor_link_length(1);
    nf.link_length_mean(iter_node) = mean(tmp_neighbor_link_length);
    nf.link_length_min(iter_node) = tmp_neighbor_link_length(end);
    
    nf.link_radius{iter_node} = link_geometric_features.dt_median(tmp_neighbor_link_list_ind);
    if mod(tmp_num_neighbor_links, 2) == 1
        nf.link_length_median(iter_node) = tmp_neighbor_link_length(ceil(tmp_num_neighbor_links/2));
    else
        tmp_mid_ind = ceil(tmp_num_neighbor_links/2);
        nf.link_length_median(iter_node) = 0.5 * (tmp_neighbor_link_length(tmp_mid_ind) + tmp_neighbor_link_length(tmp_mid_ind + 1));
    end
    % Angle between these links fun_skeleton_to_graph
    % Determine the endpoint of the link that connected to the node
    tmp_neighbor_link_ep2ep_vec = nan(3, tmp_num_neighbor_links);  
    tmp_neighbor_link_ep_ori_vec = nan(3, tmp_num_neighbor_links);  
    tmp_node_ind = vessel_graph.node.cc_ind{tmp_node_label};
    tmp_node_neighbor_ind = fun_graph_get_node_neighbor_voxel_ind(tmp_node_ind, vessel_graph.num.mask_size, 26);
    for iter_neighbor_link = 1 : tmp_num_neighbor_links
        if tmp_neighbor_link_length(iter_neighbor_link) > 1
            tmp_link_ind = vessel_graph.link.cc_ind{tmp_neighbor_link_label(iter_neighbor_link)};        
            tmp_ep1_Q = any(tmp_node_neighbor_ind == tmp_link_ind(1));
            tmp_ep2_Q = any(tmp_node_neighbor_ind == tmp_link_ind(end));
            if tmp_ep1_Q && ~tmp_ep2_Q
                % The orientation vector is defined to be pointing outward
                % (toward the nodes). Adding a minus sign reverse the
                % direction. But for computation, it's the same.
                tmp_neighbor_link_ep_ori_vec(:, iter_neighbor_link) = link_geometric_features.ep1_direction_vec(tmp_neighbor_link_list_ind(iter_neighbor_link), :)';
                tmp_neighbor_link_ep2ep_vec(:, iter_neighbor_link) = link_geometric_features.ep1_to_ep2_direction_vec(tmp_neighbor_link_list_ind(iter_neighbor_link), :)';
            elseif ~tmp_ep1_Q && tmp_ep2_Q
                tmp_neighbor_link_ep_ori_vec(:, iter_neighbor_link) = link_geometric_features.ep2_direction_vec(tmp_neighbor_link_list_ind(iter_neighbor_link), :)';
                tmp_neighbor_link_ep2ep_vec(:, iter_neighbor_link) = -link_geometric_features.ep1_to_ep2_direction_vec(tmp_neighbor_link_list_ind(iter_neighbor_link), :)';
            else
                nf.no_nan_Q(iter_node) = false;
                % Self-loop
                tmp_neighbor_link_ep2ep_vec(:, iter_neighbor_link) = link_geometric_features.ep1_to_ep2_direction_vec(tmp_neighbor_link_list_ind(iter_neighbor_link), :)';
%                 % Expand the matrix by adding trailing column
                tmp_neighbor_link_ep2ep_vec(:, end+1) = -link_geometric_features.ep1_to_ep2_direction_vec(tmp_neighbor_link_list_ind(iter_neighbor_link), :)';

                tmp_neighbor_link_ep_ori_vec(:, iter_neighbor_link) = link_geometric_features.ep1_direction_vec(tmp_neighbor_link_list_ind(iter_neighbor_link), :)';
%                 % Expand the matrix by adding trailing column
                tmp_neighbor_link_ep_ori_vec(:, end+1) = link_geometric_features.ep2_direction_vec(tmp_neighbor_link_list_ind(iter_neighbor_link), :)';
            end
        else
            nf.no_nan_Q(iter_node) = false;
        end
    end
    tmp_ep_ori_cos = tmp_neighbor_link_ep_ori_vec.' * tmp_neighbor_link_ep_ori_vec;
    tmp_ep_ori_cos = tmp_ep_ori_cos(tril(tmp_ep_ori_cos, -1) ~= 0);
    if any(tmp_ep_ori_cos > 1 | tmp_ep_ori_cos < -1)
        warning('link_ori_ep_cos is out of range');
        disp(tmp_ep_ori_cos);
        tmp_ep_ori_cos = min(1, max(-1, tmp_ep_ori_cos));
    end
    nf.link_ori_ep_cos{iter_node} = tmp_ep_ori_cos;
    
    tmp_ep2ep_cos = tmp_neighbor_link_ep2ep_vec.' * tmp_neighbor_link_ep2ep_vec;
    tmp_ep2ep_cos = tmp_ep2ep_cos(tril(tmp_ep2ep_cos, -1) ~= 0);
    if any(tmp_ep2ep_cos > 1 | tmp_ep2ep_cos < -1)
        warning('link_ep2ep_cos is out of range');
        disp(tmp_ep2ep_cos);
        tmp_ep2ep_cos = min(1, max(-1, tmp_ep2ep_cos));
    end
    nf.link_ep2ep_cos{iter_node} = tmp_ep2ep_cos;
    if tmp_num_neighbor_links >= 3
        % If degree is greater than 3, Use the first 3 link 
        nf.link_ori_ep_det(iter_node) = det(tmp_neighbor_link_ep_ori_vec(:, 1:3));
        nf.link_ep2ep_det(iter_node) = det(tmp_neighbor_link_ep2ep_vec(:, 1:3));
        % If three links are on the same plane iff the following quantities
        % are 0. The determinant is not a sufficient condition for co-plane
        tmp_ep_ori_plane_sin = fun_ori_vec_to_sin_elevation_angle(tmp_neighbor_link_ep_ori_vec);
        if tmp_ep_ori_plane_sin > 1 || tmp_ep_ori_plane_sin < 0
            warning('tmp_ep_ori_plane_sin (%f) is out of range', tmp_ep_ori_plane_sin);
            tmp_ep_ori_plane_sin = max(0, min(1, tmp_ep_ori_plane_sin));
        end               
        nf.link_ori_ep_sin_elevation(iter_node) = tmp_ep_ori_plane_sin;
        nf.link_ori_ep_cos_elevation(iter_node) = sqrt(1 - tmp_ep_ori_plane_sin.^2);
        
        tmp_ep2ep_plane_sin = fun_ori_vec_to_sin_elevation_angle(tmp_neighbor_link_ep2ep_vec);
        if tmp_ep2ep_plane_sin > 1 || tmp_ep2ep_plane_sin < 0
            warning('tmp_ep2ep_plane_sin (%f) is out of range', tmp_ep2ep_plane_sin);
            tmp_ep2ep_plane_sin = max(0, min(1, tmp_ep2ep_plane_sin));
        end        
        nf.link_ep2ep_sin_elevation(iter_node) = tmp_ep2ep_plane_sin;
        nf.link_ep2ep_cos_elevation(iter_node) = sqrt(1 - tmp_ep2ep_plane_sin.^2);
    end
end
end
function planeness = fun_ori_vec_to_sin_elevation_angle(dir_vec)
planeness = nan;
% Find the normal vector to the plane 
if size(dir_vec, 2) < 3
    return;
end
for iter_vec_1 = 1 : 2
    tmp_vec_1 = dir_vec(:, iter_vec_1);
    for iter_vec_2 = iter_vec_1 + 1 : 3
        tmp_vec_2 = dir_vec(:, iter_vec_2);
        vec_n = cross(tmp_vec_1, tmp_vec_2);
        vec_n_norm = norm(vec_n);
        if vec_n_norm > 0.01
            vec_n = vec_n ./ vec_n_norm;
            iter_vec_3 = setdiff([1,2,3], [iter_vec_1, iter_vec_2]);
            assert(isscalar(iter_vec_3));
            tmp_vec_3 = dir_vec(:, iter_vec_3);
            planeness = abs(tmp_vec_3' * vec_n);
            return;
        end
    end
end
end