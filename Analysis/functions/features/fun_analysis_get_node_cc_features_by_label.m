function nf = fun_analysis_get_node_cc_features_by_label(vessel_graph, node_label, compute_feature)
% fun_analysis_get_node_cc_features_by_label computes the features for node
% specified by node_label. The compute features influde: center of mass of
% the node, median diatance between the node voxle to the boundary, radial
% node density distribution, closest nearby node distance, label. 
% Input: 
%   vessel_graph: structure generated by fun_skeleton_to_graph, with
%   additional field of radius, which is a sparse vector that maps the
%   voxel indices to the radius of the voxel. 
%   node_label: numerical vector, specify the nodes for computing the
%   features 
%   compute_feature: cell of string, control the features to be computed. 
% Ouput:
%   nf: structure with fields:
%       dt_mean: numerical vector, mean of the radius of the node voxels
%       int_mean: numerical vector, mean of the intenisty of the node voxels
%       nearest_node_dist: numerical vector, distnace to the nearest
%       neighbor node
%       nearest_node_label: numerical vector, label of the nearest neighbor
%       node
%       center_of_mass: N-by-3 numerical vector, the center of mass
%       location of the node in the array
%       radial_node_count, radial_node_count_edge: histogram count
%       of the number of node in the radial direction 
%       neighbor_node_label    
%       radial_node_density: radial_node_count normalized by the volume of
%       the radial sphere shell
%       neighbor_node_label, neighbor_node_dist: label and distnace of
%       nodes within a threshold distant from the node
%
% Implemented by Xiang Ji on 03/27/2019
% Modified by Xiang Ji on 10/24/2019
% 1. Add the ranking of the directly connected node in the neighboring
% nodes

%% Phase input
if nargin < 2
    node_label = 1 : vessel_graph.node.num_cc;
end
if nargin < 3
    compute_feature = {'geometry', 'dt'};
end
vessel_mask_dt = vessel_graph.radius;
dt_is_sparse = issparse(vessel_mask_dt);
image_size = vessel_graph.num.mask_size;

num_node = numel(node_label);
nf = fun_initialized_structure_array_with_fieldname_list({'dt_mean', 'nearest_node_dist', ...
    'nearest_node_label', 'center_of_mass', 'radial_node_count', 'radial_node_count_edge', ...
    'neighbor_node_label', 'neighbor_node_dist', 'radial_node_density', 'global_ind', ...
    'conn_neig_dist_rank'});

[nf.dt_mean, nf.nearest_node_dist, nf.nearest_node_label, ] = deal(nan(num_node, 1));
[nf.radial_node_count, nf.radial_node_count_edge, nf.neighbor_node_label, ...
        nf.neighbor_node_dist, nf.radial_node_density, nf.conn_neig_dist_rank] = deal(cell(num_node, 1));
nf.center_of_mass = zeros(3, num_node);

if num_node == 0
    return;
end

if any(ismember(compute_feature, 'geometry'))
    compute_geometryQ = true;
else
    compute_geometryQ = false;
end
if any(ismember(compute_feature, 'dt'))
    compute_dtQ = true;
else
    compute_dtQ = false;
end
%% Computation
% Get the center of mass for all the nodes
node_CoM = zeros(3, vessel_graph.node.num_cc);
node_first_voxel_sub = zeros(3, vessel_graph.node.num_cc);
for iter_node = 1 : vessel_graph.node.num_cc
    tmp_ind = vessel_graph.node.cc_ind{iter_node};
    tmp_sub = fun_ind2sub(image_size, tmp_ind);
    if compute_geometryQ
        if isvector(tmp_sub)
            node_CoM(:, iter_node) = tmp_sub;
            node_first_voxel_sub(:, iter_node) = tmp_sub;
        else
            node_CoM(:, iter_node) = mean(tmp_sub, 1);
            node_first_voxel_sub(:, iter_node) = tmp_sub(1, :);
        end
    end
end
node_CoM = node_CoM';
node_first_voxel_sub = node_first_voxel_sub.';

for iter_node = 1 : num_node
    tmp_ind = vessel_graph.node.cc_ind{node_label(iter_node)};
    if compute_dtQ
        if dt_is_sparse
            nf.dt_mean(iter_node) = mean(full(vessel_mask_dt(tmp_ind)));
        else
            nf.dt_mean(iter_node) = mean(vessel_mask_dt(tmp_ind));
        end
    end
end
nf.center_of_mass = node_CoM(node_label, :);
if isfield(vessel_graph, 'info') && isfield(vessel_graph.info, 'bbox_mmxx')
    node_first_voxel_sub_global = node_first_voxel_sub + vessel_graph.info.bbox_mmxx(1:3) - 1;
    node_first_voxel_ind_global = sub2ind(vessel_graph.info.dataset_size, ...
        node_first_voxel_sub_global(:, 1), node_first_voxel_sub_global(:, 2), ...
        node_first_voxel_sub_global(:, 3));
    nf.global_ind = node_first_voxel_ind_global(node_label);
else
    nf.global_ind = nan(num_node, 1);
end
nf.degree = vessel_graph.node.num_link(node_label);
%% Radial density function 
record_neighbor_label_r = 50;
radial_binning_edge = [0:10:100, 125:25:500, 550:50:1000, 1100:100:5000];
if compute_geometryQ
    nf.distance_to_boundary = min(min(nf.center_of_mass, image_size - nf.center_of_mass + 1), [], 2);
    
    if num_node > 1
        node_pdist = pdist2(node_CoM, nf.center_of_mass);
        for iter_node = 1 : num_node
            tmp_node_neighbor_dist = node_pdist(:, iter_node);
            % Compute the ranking of the connected node. 
            nf.conn_neig_dist_rank{iter_node} = fun_analysis_get_connected_node_neighbor_distance_ranking(vessel_graph, ...
                node_label(iter_node), tmp_node_neighbor_dist, true);
            
            tmp_valid_neighbor_label = find(tmp_node_neighbor_dist <= nf.distance_to_boundary(iter_node) & tmp_node_neighbor_dist > 0);
            
            tmp_valid_neighbor_dist = tmp_node_neighbor_dist(tmp_valid_neighbor_label);
            tmp_bin = radial_binning_edge(radial_binning_edge < nf.distance_to_boundary(iter_node));
            if numel(tmp_bin) > 1
                [tmp_count, tmp_edge] = histcounts(tmp_valid_neighbor_dist, tmp_bin);
                tmp_radial_layer_vol = 4 * pi / 3 .* (tmp_edge(2:end).^3 - tmp_edge(1:end-1).^3);
                nf.radial_node_count{iter_node} = tmp_count;
                nf.radial_node_count_edge{iter_node} = tmp_edge;
                nf.radial_node_density{iter_node} = tmp_count ./ tmp_radial_layer_vol;
            end
            tmp_record_neighbor_Q = (tmp_valid_neighbor_dist <= record_neighbor_label_r);
            if any(tmp_record_neighbor_Q)
                tmp_record_neighbor_label = tmp_valid_neighbor_label(tmp_record_neighbor_Q);
                tmp_record_neighbor_dt = tmp_valid_neighbor_dist(tmp_record_neighbor_Q);
                % Sort
                [tmp_record_neighbor_dt, tmp_idx] = sort(tmp_record_neighbor_dt, 'ascend');
                tmp_record_neighbor_label = tmp_record_neighbor_label(tmp_idx);
                
                nf.nearest_node_dist(iter_node) = tmp_record_neighbor_dt(1);
                nf.nearest_node_label(iter_node) = tmp_record_neighbor_label(1);
                nf.neighbor_node_label{iter_node} = tmp_record_neighbor_label;
                nf.neighbor_node_dist{iter_node} = tmp_record_neighbor_dt;
            elseif ~isempty(tmp_valid_neighbor_dist)
                [min_dist, min_idx] = min(tmp_valid_neighbor_dist);
                nf.nearest_node_dist(iter_node) = min_dist;
                nf.nearest_node_label(iter_node) = tmp_valid_neighbor_label(min_idx);
            end
        end
    end
end

if num_node == 1
    nf = struct2table(nf, 'AsArray', true);
else
    nf = struct2table(nf);
end

end