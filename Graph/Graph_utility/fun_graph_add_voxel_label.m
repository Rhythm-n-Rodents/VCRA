function vessel_graph = fun_graph_add_voxel_label(vessel_graph, ind_to_voxel_label, unlabel_conflict_Q)
% fun_graph_add_voxel_label add the labels for all the voxels in the links
% and nodes. (Note: the isolated points are ignored)
% Input:
%   vessel_graph: structure generated by fun_skeleton_to_graph
%   ind_to_voxel_label: sparse vector or array that maps the voxel indices
%   to label. By default, 0 for non-existing voxel, 1 for unlabeled voxel
%   and numbers greater than 1 are real labels. 
%   unlabel_conflict_Q: the default value is true. If true, if a link or
%   node connected component has more than 1 meaningful label, the label of
%   all its voxel will be converted to unlabeled (1). 
% Output: 
%   vessel_graph: with new fields label that is a  sparse matrix in which
%   each non zero element is the label of the voxels.
%
% Implemented by Xiang Ji on 07/19/2019

if nargin < 3
    unlabel_conflict_Q = true;
end
unlabel_idx = 1; 

if issparse(ind_to_voxel_label)
    map_is_sparse_Q = true;
else
    map_is_sparse_Q = false;
end

cc_ind = cat(1, vessel_graph.node.cc_ind, vessel_graph.link.cc_ind);
if ~isempty(vessel_graph.isopoint.pos_ind)
    cc_ind = cat(1, cc_ind, num2cell(vessel_graph.isopoint.pos_ind));
end
if isfield(vessel_graph, 'isoloop')
    cc_ind = cat(1, cc_ind, vessel_graph.isoloop.cc_ind);
end
num_cc = numel(cc_ind);
cc_label = cell(num_cc, 1);
for iter_cc = 1 : num_cc
    tmp_ind = cc_ind{iter_cc};
    if map_is_sparse_Q
        tmp_label = full(ind_to_voxel_label(tmp_ind));
    else
        tmp_label = ind_to_voxel_label(tmp_ind);
    end
    tmp_label_unique = unique(tmp_label);
    tmp_label_non_zero = tmp_label_unique(tmp_label_unique ~= 0);
    if isscalar(tmp_label_non_zero)
        % Replace the 0 with the label
        cc_label{iter_cc} = ones(numel(tmp_ind), 1) .* tmp_label_non_zero;
    else
        if unlabel_conflict_Q
            % If have more than 1 voxel label, convert the entire cc to be
            % unlabeled. 
            cc_label{iter_cc} = ones(numel(tmp_ind), 1) .* unlabel_idx;
        else
            % If do not unlabel the cc that have voxels of more than 1
            % type of label, keep the label
           cc_label{iter_cc} = tmp_label;
        end
    end
end
cc_ind = cat(1, cc_ind{:});
cc_label = cat(1, cc_label{:});

num_voxels = numel(cc_ind);
assert(vessel_graph.num.block_voxel == numel(ind_to_voxel_label), 'The number of voxels in the label map is different from the total number of voxels in the mask from which the graph is comptued');
vessel_graph.label = sparse(cc_ind, ones(num_voxels, 1), cc_label, ...
    numel(ind_to_voxel_label), 1);
end