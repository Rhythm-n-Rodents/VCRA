function [paired_descriptor] = fun_sample_matched_descriptor(paired_descriptor, opt)
% fun_sample_matched_descriptor is sampling the matched descriptors. The
% number of matched edge voxels is much larger than the number of matched
% skeleton voxels. Since some images has capillaries dominant on one side
% of the tile while large vessels dominant on the other side, for computing
% the overall homography, we reduce the number of edge voxels by uniformly
% sample them from the space. 
%
% Input: 
%   paired_descriptor: MATLAB structure, pairedescriptor generated by
%   vessel descriptor extraction function. 
%   opt: MATLAB structure, whose field and default value are listed below. 
% Output:
%   paired_descriptor: MATLAB structure, with updated filed X, Y (and
%   X_int, Y_int);
%
% Implemented by Xiang Ji on 05/08/2019
%% Default value
if nargin < 2
    opt = struct;
end
if isfield(opt, 'sample_block_scale')
    sample_block_scale = opt.sample_block_scale;
else
    sample_block_scale = 10;
end
if isfield(opt, 'sample_block_size')
    sample_block_size = opt.sample_block_size;
else
    sample_block_size = [3, 3, 1] .* sample_block_scale;
end
if isfield(opt, 'downsample_edgeQ')
    downsample_edgeQ = opt.downsample_edgeQ;
else
    downsample_edgeQ = true;
end
if isfield(opt, 'downsample_skelQ')
    downsample_skelQ = opt.downsample_skelQ;
else
    downsample_skelQ = false;
end
if isfield(opt, 'num_sample_per_block')
    num_sample_per_block = opt.num_sample_per_block;
else
    num_sample_per_block = ceil(prod(sample_block_size) * 1e-3);
end
%% Downsampling
if downsample_edgeQ && downsample_skelQ
    [paired_descriptor.X, sampled_ind] = fun_uniform_sample_points_in_space(paired_descriptor.X, sample_block_size, num_sample_per_block, 'random');
    paired_descriptor.Y = paired_descriptor.Y(sampled_ind, :);
    if isfield(paired_descriptor, 'X_int')
        warning('X_int and Y_int are not sampled');
    end
    return;
end

if ~isempty(paired_descriptor.X_skl) && downsample_skelQ
%     num_sample_per_block = ceil(sample_block_scale/3);
    [X_skel_sampled, sampled_ind] = fun_uniform_sample_points_in_space(paired_descriptor.X_skl, sample_block_size, num_sample_per_block, 'random');
    Y_skel_sampled = paired_descriptor.Y_skl(sampled_ind, :);
    X_skel_sampled_int = paired_descriptor.X_skl_int(sampled_ind);
    Y_skel_sampled_int = paired_descriptor.Y_skl_int(sampled_ind);
else
    X_skel_sampled = paired_descriptor.X_skl;
    Y_skel_sampled = paired_descriptor.Y_skl;
    X_skel_sampled_int = paired_descriptor.X_skl_int;
    Y_skel_sampled_int = paired_descriptor.Y_skl_int;
end

if ~isempty(paired_descriptor.X_edge) && downsample_edgeQ
%     num_sample_per_block = ceil(prod(sample_block_size) * 1e-3);
    [X_edge_sampled, sampled_ind] = fun_uniform_sample_points_in_space(paired_descriptor.X_edge, sample_block_size, num_sample_per_block, 'random');
    Y_edge_sampled = paired_descriptor.Y_edge(sampled_ind, :);
    %             X_edge_sampled_int = X_edge_int(sampled_ind);
    %             Y_edge_sampled_int = Y_edge_int(sampled_ind);
    X_edge_sampled_int = [];
    Y_edge_sampled_int = [];
else
    X_edge_sampled = paired_descriptor.X_edge;
    Y_edge_sampled = paired_descriptor.Y_edge;
    X_edge_sampled_int = [];
    Y_edge_sampled_int = [];
    %             X_edge_sampled_int = X_edge_int;
    %             Y_edge_sampled_int = Y_edge_int;
end

paired_descriptor.X = cat(1, X_skel_sampled, X_edge_sampled);
paired_descriptor.Y = cat(1, Y_skel_sampled, Y_edge_sampled);
paired_descriptor.X_int = cat(1, X_skel_sampled_int, X_edge_sampled_int);
paired_descriptor.Y_int = cat(1, Y_skel_sampled_int, Y_edge_sampled_int);
end