function refine_tile_info = fun_get_tile_indices_for_feature_match_refinement(featmap,directions,scopeloc,num_matches_thr_1, num_matches_thr_2)
% This function is used for refining the descriptor matches. The tile to be
% refined is determined by the number of matched descriptors, thresholded
% by numthr. The tiles with number of matched descriptors greater than
% numthr are defined as valid tiles. The invalid tiles' pixel displacement
% is re-estimated as the average of their K-NN valid tiles' displacement.
% Note that the displacement is reliable for tiles on the same xy plane,
% while displacement between z direction is amlost independent. 
% Input: 
%   featmap: cell array generated by loadMatchedFeatures
%   directions: char, one of {'Z', 'X', 'Y'}. In practices, only 'Z' is
%   used. 
%   scopeloc: structure with fields: 
%       gridix: N-by-4 numerical array, tile grid location (x, y, z, cut_count)
%       relativepaths: relative path to the folder that contains the image
%       and acquisition informations. 
%       filepath: N-by-1 cell array, each cell is the string of filepath to
%       the acquisition file. 
%       loc: N-by-3 numerical array, stage physical position
%
%
% Adapted from Erhan Bas's initTiles by Xiang Ji on May 23, 2019

if nargin<4
    num_matches_thr_1 = 500;
elseif nargin < 5
    num_matches_thr_2 = num_matches_thr_1 * 0.5;
end
assert(num_matches_thr_1 > num_matches_thr_2);

num_neighbor = 2;

numtiles = length(featmap);
pixel_shift_all = nan(3, numtiles);
pixel_shift_skel = nan(3, numtiles);
pixel_shift_edge = nan(3, numtiles);
pixel_shift_fft = nan(3, numtiles);
pixel_shift_stage = nan(3, numtiles);
num_matches = zeros(numtiles,1);
%%
for ii = 1:numtiles
    feat = featmap(ii).(genvarname(directions));
    if ~isempty(feat) && ~isempty(feat.paireddescriptor.Y)
        % The subscripts on x, y direciton were flipped before saved to the
        % hard drive. THe minus sign below account for that flip. 
        num_matches(ii) = size(feat.paireddescriptor.X, 1);
        med_pix_shift = median(feat.paireddescriptor.X - feat.paireddescriptor.Y); 
        med_pix_shift(1:2) = - med_pix_shift(1:2);
        pixel_shift_all(:, ii) = med_pix_shift;
        
        if ~isempty(feat.paireddescriptor.pixshift_stage)
            pixel_shift_stage(:, ii) = feat.paireddescriptor.pixshift_stage;
        end
        if ~isempty(feat.paireddescriptor.pixshift_skl)
            pixel_shift_skel(:, ii) = feat.paireddescriptor.pixshift_skl;
        end
        if ~isempty(feat.paireddescriptor.pixshift_edge)
            pixel_shift_edge(:, ii) = feat.paireddescriptor.pixshift_edge;
        end
        if ~isempty(feat.paireddescriptor.pixshift_mask_fft)
            pixel_shift_fft(:, ii) = feat.paireddescriptor.pixshift_mask_fft;
        end
        
    end
end
%% Find the outlier for each section 
[section_list_ind, ~] = fun_bin_data_to_idx_list(scopeloc.gridix(:, 3));
max_num_matches_in_section = nan(numel(section_list_ind), 1);
for iter_sec = 1 : numel(section_list_ind)
    max_num_matches_in_section(iter_sec) = max(num_matches(section_list_ind{iter_sec}));
end
max_num_matches_in_section = max(num_matches_thr_2, max_num_matches_in_section);
max_num_matches_thr = repelem(max_num_matches_in_section, cellfun(@numel, section_list_ind));
max_num_matches_thr = min(max_num_matches_thr, num_matches_thr_1);
% test_section = 25;
% tmp_list_ind = section_list_ind{test_section};
% tmp_list_pos_xy = scopeloc.gridix(tmp_list_ind, 1:2);
% tmp_list_pos_min = min(tmp_list_pos_xy, [], 1);
% tmp_list_pos_max = max(tmp_list_pos_xy, [], 1);
% tmp_valid_plane_size = tmp_list_pos_max - tmp_list_pos_min + 1;
% tmp_list_xy_ind = sub2ind(tmp_valid_plane_size, tmp_list_pos_xy(:, 1) - tmp_list_pos_min(1) + 1, ...
%     tmp_list_pos_xy(:, 2) - tmp_list_pos_min(2) + 1);
% 
% [tmp_num_match_mat, tmp_pixshift_1, tmp_pixshift_2, tmp_pixshift_3] = deal(nan(tmp_valid_plane_size));
% 
% tmp_num_match_mat(tmp_list_xy_ind) = nummatches(tmp_list_ind);
% tmp_match_mat_valid_Q = tmp_num_match_mat > numthr;
% tmp_pixshift_1(tmp_list_xy_ind) = pixel_shift_all(1, tmp_list_ind);
% tmp_pixshift_2(tmp_list_xy_ind) = pixel_shift_all(2, tmp_list_ind);
% tmp_pixshift_3(tmp_list_xy_ind) = pixel_shift_all(3, tmp_list_ind);
% % The first axis is the most reliable one and thus should be very
% % consistent. 
% [tmp_pixshift_1_diff_2, tmp_pixshift_1_diff_1] = gradient(tmp_pixshift_1);
% [tmp_pixshift_2_diff_2, tmp_pixshift_2_diff_1] = gradient(tmp_pixshift_2);
% [tmp_pixshift_3_diff_2, tmp_pixshift_3_diff_1] = gradient(tmp_pixshift_3);
% % Compute the averaged neighbor displacement deviation, weighted by the
% % nubmer of matches for each column 
% tmp_avg_disp_dev_3_1 = sum(abs(tmp_pixshift_3_diff_1) .* tmp_num_match_mat, 1, 'omitnan') ./ sum(tmp_num_match_mat, 1, 'omitnan');
% tmp_disp_dev_3_1_n = tmp_pixshift_3_diff_1 ./ tmp_avg_disp_dev_3_1;
% 
% tmp_tile_to_refine_ind = find(~tmp_match_mat_valid_Q & ~isnan(tmp_num_match_mat));
%%
pixel_shift_all = pixel_shift_all.';
pixel_shift_skel = pixel_shift_skel.';
pixel_shift_edge = pixel_shift_edge.';
pixel_shift_fft = pixel_shift_fft.';
pixel_shift_stage = pixel_shift_stage';

% build kdtree
is_inliers_Q = all(isfinite(pixel_shift_all),2) & num_matches >= max_num_matches_thr;
inliers = find(is_inliers_Q);
anchors = scopeloc.gridix(is_inliers_Q, 1:3);
queries = scopeloc.gridix(~is_inliers_Q, 1:3);
[IDX, dist2neighbor]= knnsearch(anchors, queries, 'K', num_neighbor ,'distance',@knn_dist);
assert(issorted(dist2neighbor, 2), 'The distance list to the valid neighbors is not in ascending order');

refine_tile_info = struct;
refine_tile_info.ori_median_pixel_shift = pixel_shift_all;
refine_tile_info.ori_num_meaches = num_matches;

refine_tile_info.outlier_list_ind = find(~is_inliers_Q);
refine_tile_info.outlier_gridix = scopeloc.gridix(~is_inliers_Q, :);
refine_tile_info.outlier_relative_path = scopeloc.relativepaths(~is_inliers_Q, :);
refine_tile_info.outlier_acquisition_fp = scopeloc.filepath(~is_inliers_Q);

refine_tile_info.outlier_ori_pxlshift_skl = pixel_shift_skel(~is_inliers_Q, :);
refine_tile_info.outlier_ori_pxlshift_edge = pixel_shift_edge(~is_inliers_Q, :);
refine_tile_info.outlier_ori_pxlshift_fft = pixel_shift_fft(~is_inliers_Q, :);
refine_tile_info.outlier_ori_pxlshift_stage = pixel_shift_stage(~is_inliers_Q, :);

% Average pixel shift of neighbors
neighbor_list_ind = inliers(IDX(:));
aprox_pix_shift_1 = round(mean(reshape(pixel_shift_all(neighbor_list_ind, 1), size(IDX)), 2));
aprox_pix_shift_2 = round(mean(reshape(pixel_shift_all(neighbor_list_ind, 2), size(IDX)), 2));
aprox_pix_shift_3 = round(mean(reshape(pixel_shift_all(neighbor_list_ind, 3), size(IDX)), 2));

refine_tile_info.outlier_est_pix_shift = cat(2, aprox_pix_shift_1, aprox_pix_shift_2, ...
    aprox_pix_shift_3);
refine_tile_info.outlier_2_knn_dist_avg = mean(dist2neighbor, 2); % Used for checking the reliability of the estimation 
refine_tile_info.outlier_neighbor_list_ind = inliers(IDX);
refine_tile_info.updated_median_pixel_shift = pixel_shift_all;
refine_tile_info.updated_median_pixel_shift(refine_tile_info.outlier_list_ind, :) = refine_tile_info.outlier_est_pix_shift;
end
%%
function  d = knn_dist(ZI,ZJ,W)
if nargin<3
    W = [1 2.5 1e6];
end
dvec = ones(size(ZJ,1),1) * ZI - ZJ;
d = sqrt( sum(( dvec*diag(W) ) .* dvec,2));
end
