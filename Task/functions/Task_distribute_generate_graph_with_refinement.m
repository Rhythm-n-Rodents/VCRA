clc;clear;
set_env;
DataManager = FileManager;
dataset_name = 'WholeBrain';
stack = 'ML_2018_08_15';
grid_c_version = '240_cube_combined_5_o_1';
grid_c = DataManager.load_grid(dataset_name, stack, grid_c_version);
grid_info = grid_c.grid_ori;
grid_version = grid_info.version;
task_function_name = 'fun_task_generate_graph_with_refinement';
script_root_folder = DataManager.SCRIPT_PATH;
classifier_folder_path = fullfile(DataManager.fp_metadata_folder(dataset_name, stack), 'classifier');
%% Task information
task_str = struct;
task_str.dataset_name = dataset_name;
task_str.stack = stack;
task_str.DataManager = FileManager;
task_str.task_name = sprintf('Generate_graph_with_refinement_%s', datestr(now, 'yyyymmdd'));
task_str.task_function_name = task_function_name;
task_str.grid_c_version = grid_c_version;
task_str.grid_c_info = grid_c;
%% Task specific parameters
opt = struct;
opt.output_graph_name = sprintf('%s_auto', grid_c_version);
opt.output_skel_name = sprintf('%s_auto', grid_info.version);
% Parameter for skeleton recentering 
opt.mask2graph.max_rc_int = 40000;
% Parameter for filling holes in the segmentation mask 
opt.mask2graph.node_bbox_expand = 20;
% Classifier
GR_classifier = struct;
GR_classifier.link_ep1 = load(fullfile(classifier_folder_path, 'classifier_link_ep1_to_remove.mat'), 'used_feature_name', 'classifier');
GR_classifier.dim_short_link = load(fullfile(classifier_folder_path, 'classifier_dim_short_link_to_remove.mat'), 'used_feature_name', 'classifier');
GR_classifier.linker = load(fullfile(classifier_folder_path, 'classifier_linker_to_remove.mat'), 'used_feature_name', 'classifier');
GR_classifier.link_ep1_af = load(fullfile(classifier_folder_path, 'classifier_link_ep1_artefact_to_remove.mat'), 'used_feature_name', 'classifier');
opt.classifier = GR_classifier;
% Parameter for automatic hair, self-loop and bilink loop removal
opt.max_self_loop_length = 30;
opt.internal_offset = 16;
opt.pruning_max_length = 2;
opt.max_bilink_loop_length = 15;
% Parameters for link with 1 endpoint classification
% Links that are classified to be generated by stitching artefact would not
% be deleted if they are shorter than this length. This is to reduce the
% false positive rate. 
opt.min_artefact_link_ep1_length = 15; 
% Parameter for selecting candidate link for classifier
opt.select_dim_short_link = struct;
opt.select_dim_short_link.min_int_max = 22000;
opt.select_dim_short_link.dt_ep_sum_2_ep_dist_min = 0.15;
opt.select_dim_short_link.max_length = 25;

opt.select_short_loop.max_length = 150;
% Parameters for controling the conditions 
opt.annotation_on_Q = false;
opt.auto_refine_cycle = 3;

opt.save_combined_grid_Q = true;
opt.overwrite_existing_graphQ = false;
opt.overwrite_skl_Q = false;

opt.grid_c = grid_c;

task_str.task_option = opt;
%% Task distributed information
dist_info_cell = repelem({'MACHINE 1'}, 1, 18);

task_str.overwrite_Q = false;
num_processor = size(dist_info_cell, 2);
random_shuffle_task_Q = true;
%% Distribute task
task_list = 1 : grid_c.num_valid_cube;
num_task = numel(task_list);

avg_num_task_per_process = ceil(num_task/num_processor);
begin_idx = 1 : avg_num_task_per_process : num_task;
end_idx = min(num_task, begin_idx + avg_num_task_per_process - 1);
assert(numel(end_idx) == num_processor && end_idx(end) == num_task);
if random_shuffle_task_Q
    if isrow(task_list)                                                                             
        task_list = task_list.';
    elseif size(task_list, 1) < size(task_list, 2)
        warning('Number of row is less than number of column in the task list');
    end
    task_list = task_list(randperm(size(task_list,1)), :);
end
%% Check segmentation integrity
segmentation_folder = DataManager.fp_mask_folder(dataset_name, stack, grid_version);
segmentation_list = dir(sprintf('%s/*.mat', segmentation_folder));
segmentation_file_name_prefix = sprintf('%s_%s_%s_block_data_', dataset_name, stack, grid_version);

if numel(segmentation_list) ~= grid_info.num_valid_cube
    % Check which one is missing 
    segmentation_file_array = false(grid_info.grid_size);
    for iter_file = 1 : numel(segmentation_list)
        tmp_name = erase(segmentation_list(iter_file).name, segmentation_file_name_prefix);
        [~, tmp_name, ~] = fileparts(tmp_name);
        tmp_name = cellfun(@str2double, strsplit(tmp_name, '_'));
        segmentation_file_array(tmp_name(1), tmp_name(2), tmp_name(3)) = true;
    end
    missing_file_grid_ind = find(~segmentation_file_array & ~isnan(grid_info.bbox_grid_label_array));
    missing_file_grid_sub = fun_ind2sub(grid_info.grid_size, missing_file_grid_ind);
else
    fprintf('Finish checking the number of available segmentation files\n');
end
%%
DataManager.sync_script_to_server;
for iter_task = 1 : num_processor
    tmp_task_str = task_str;
    tmp_task_str.machine_name = dist_info_cell{1, iter_task};
    tmp_task_str.gpuDevice = [];
    tmp_task_str.task_list = task_list(begin_idx(iter_task) : end_idx(iter_task) , :);    
    [tmp_cmd, tmp_task_str] = fun_task_get_task_str(tmp_task_str, iter_task, true);
    DataManager.run_command_on_machine(tmp_task_str.machine_name, tmp_task_str.task_cmd_bs);
end
%% Debug
% fun_task_generate_graph_with_refinement(tmp_task_str.filepath);
%%
% tmp_im = DataManager.load_blocks_files('image', dataset_name, stack, '240_cube', 8, 28, 34);
% tmp_mask = DataManager.load_blocks_files('mask', dataset_name, stack, '240_cube', 8, 28, 34);
% tmp_skl =  DataManager.load_block_skl(dataset_name, stack, '240_cube_auto', 8, 28, 34);
% volumeViewer(tmp_im)
% volumeViewer(tmp_mask)
% fun_task_generate_graph_with_refinement(tmp_task_str.filepath);
% fun_task_generate_graph_with_refinement('/data/Vessel/WholeBrain/ML_2019_01_24/task/Generate_graph_with_refinement_20190816/Generate_graph_with_refinement_20190816_processor_2.mat');
% 
% rerun_list = task_list(1171:end);
% for iter_rerun = 1 : numel(rerun_list)
%     tic
%     exit_code = fun_graph_mask_to_refined_graph_and_skel(dataset_name, stack, grid_c_version, rerun_list(iter_rerun), opt);
%     exit_code = fun_graph_mask_to_refined_graph_and_skel(dataset_name, stack, grid_c_version, 200, opt);
%     toc
% end
% recon_r_ori = fun_graph_get_cc_radius(cat(1, vessel_graph.link.cc_ind, vessel_graph.node.cc_ind), vessel_mask_dt);
% recon_ind_ori = cat(1, vessel_graph.link.cc_ind{:}, vessel_graph.node.cc_ind{:});
% recon_ori = fun_skeleton_reconstruction(recon_ind_ori, recon_r_ori, vessel_graph.num.mask_size);
% vis_mask = uint8(recon_ori);
% vis_mask(vessel_graph.link.pos_ind) = 2;
% vis_mask(vessel_graph.node.pos_ind) = 3;
% DataManager.visualize_itksnap(vessel_image, vis_mask);